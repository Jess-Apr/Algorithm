// 문제 번호: 10844번

// 백준 제출용 코드
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "./example.txt";
const input = fs.readFileSync(filePath).toString().trim();
const num = +input;

// dp 배열에는 길이가 n인 계단수에서 각 숫자로 끝나는 계단수의 갯수를 저장한다.
const dp = Array.from({ length: num + 1 }, () => new Array(10));
dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1];
dp[2] = [1, 1, 2, 2, 2, 2, 2, 2, 2, 1];

// dp[1]과 dp[2]는 미리 설정해두어 3자릿수부터 시작
for (let n = 3; n <= num; n++) {
  for (let i = 0; i < 10; i++) {
    // 0으로 끝나는 계단수는 마지막 숫자의 이전 수가 1이어야만 한다.
    // -1로 시작하는 수는 없으니 n - 1자릿수에서 1로 끝나는 계단수의 갯수만 더해준다.
    if (i === 0) {
      dp[n][i] = dp[n - 1][i + 1] % 1000000000;
    } else if (i >= 1 && i <= 8) {
      // 1 ~ 8로 끝나는 계단수는 마지막 숫자의 이전수가 (마지막 숫자 - 1) 또는 (마지막 숫자 + 1)이면 된다.
      // n - 1자릿수에서 (마지막 숫자 - 1)로 끝나는 계단수의 갯수와 (마지막 숫자 + 1)로 끝나는 계단수의 갯수 두가지를 더해준다.
      dp[n][i] = (dp[n - 1][i - 1] + dp[n - 1][i + 1]) % 1000000000;
    } else if (i === 9) {
      // 9로 끝나는 계단수는 마지막 숫자의 이전수가 8이어야만 한다.
      // 0으로 시작하는 수는 계단수가 아니므로 n - 1자릿수에서 8로 끝나는 계단수의 갯수만 더해준다.
      dp[n][i] = dp[n - 1][i - 1] % 1000000000;
    }
  }
}
// 각 숫자를 1000000000으로 나눠주는 이유는 숫자가 커 BigInt가 되면 계산이 제대로 안되기 때문이다.

// dp[n]의 총 합을 구해 n자릿수를 가지는 계단수를 구한다.
let sum = dp[num].reduce((acc, cur) => acc + cur);
// 총합도 1000000000로 나누어 출력한다.
console.log(sum % 1000000000);
